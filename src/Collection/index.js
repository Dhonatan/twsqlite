import invariant from '../utils/common/invariant';
import encodeQuery from '../adapters/sqlite/encodeQuery';
import encodeInsert, {
  encodeInsertWithoutValues,
  encodeInsertValues,
} from '../adapters/sqlite/encodeInsert';
import encodeUpdate from '../adapters/sqlite/encodeUpdate';
import {createTimestampsFor} from '../utils/common/createTimestampsFor';
import Query from '../Query';
import { validate as uuidValidate } from 'uuid';
import uuid from 'react-native-uuid'

export default class Collection {
  database;

  modelClass;

  MIN_ID = 1000000;

  MAX_INSERTS_IN_QUERY = 500;

  constructor(database, ModelClass) {
    this.database = database;
    this.modelClass = ModelClass;

    this.columnsAutogeneratedByORM = {
      id: '',
      created_at: '',
      updated_at: '',
    };
  }

  get table() {
    return this.modelClass.table;
  }

  get schema() {
    return this.database.schema.tables[this.table];
  }

  // Finds a record with the given ID
  // Promise will reject if not found
  async find(id) {
    try {
      invariant(id, `Invalid record ID ${this.table}#${id}`);

      const validUUid = uuidValidate(id)
      const where = validUUid ? "UUID = '" + id + "'" : "UUID = " + id

      const query = `${encodeQuery({table: this.table})} WHERE ${where}`;
      const response = await this.query(query);
      const record = this._fetchRecord(response);

      return record[0] || {};
    } catch (err) {
      return new Error('[SQL FIND ERROR] ', err);
    }
  }

  // Don't invert the order of the conditions
  getExtraConditions({where, limit, offset, groupBy, orderBy}) {
    let query = '';

    if (where) {
      query += `WHERE ${where}`;
    }
    if (groupBy) {
      query += ` GROUP BY ${groupBy}`;
    }
    if (orderBy) {
      query += ` ORDER BY ${orderBy}`;
    }
    if (limit) {
      query += ` LIMIT ${limit}`;
    }
    if (offset || offset === 0) {
      query += ` OFFSET ${offset}`;
    }

    return query;
  }

  /**
   * Finds a record with the given ID
   * Promise will reject if not found
   */
  async findAll(options = {}) {
    try {
      const query = `${encodeQuery({table: this.table})}`;
      const extraConditions = this.getExtraConditions(options);
      const response = await this.query(`${query} ${extraConditions}`);

      return this._fetchRecord(response);
    } catch (err) {
      return new Error('[SQL FINDALL ERROR] ', err);
    }
  }

  async query(string, values = []) {
    try {
      const queryInstance = new Query(this, []);

      return await queryInstance.query(string, values);
    } catch (err) {
      return new Error('[SQL QUERY ERROR] ', err);
    }
  }

  _fetchId(record) {
    const id = record[0].id || this.MIN_ID;

    const infoId = uuid();

    return id === 1 ? infoId : id > this.MIN_ID ? id : this.MIN_ID;
  }

  async getNextId() {
    try {
      const query = `SELECT (MAX(ID) + 1) AS id FROM ${this.table}`;
      const response = await this.query(query);
      const record = this._fetchRecord(response);

      return this._fetchId(record);
    } catch (err) {
      return new Error('[SQL GETNEXTID ERROR]', err);
    }
  }

  async create(recordBuilder) {
    try {
      const id = await this.getNextId();
      const timestamps = createTimestampsFor(recordBuilder);
      const query = encodeInsert({
        table: this.table,
        raw: {
          id,
          created_at: timestamps.created_at,
          updated_at: timestamps.updated_at,
          ...recordBuilder,
        },
      });

      await this.query(query[0], query[1]);

      return {id, ...recordBuilder};
    } catch (err) {
      return new Error('[SQL CREATE ERROR] ', err);
    }
  }

  async multipleInserts(recordBuilder, options = {}) {
    try {
      const {numberInsertsPerBatch, generateId, generateTimestamps} = options;
      const MAX_INSERTS = numberInsertsPerBatch || this.MAX_INSERTS_IN_QUERY;
      const LAST_POSTION = recordBuilder.length - 1;
      const insertScope = encodeInsertWithoutValues({
        table: this.table,
        raw: {
          ...this.columnsAutogeneratedByORM,
          ...recordBuilder[0],
        },
      });

      let insertValues = [];

      for (const r in recordBuilder) {
        // the variable "r" is a string
        const recordPos = Number(r);
        const record = {
          ...this.columnsAutogeneratedByORM,
          ...recordBuilder[recordPos],
        };
        // if the recordPos is zero then "0 % 0" is equal to 0. This way, don't has a batch
        const isFirstPosition = recordPos === 0;
        const hasBatch = isFirstPosition
          ? false
          : recordPos % MAX_INSERTS === 0;

        if (generateId) {
          record.id = await this.getNextId();
        }

        if (generateTimestamps) {
          const timestamps = createTimestampsFor(recordBuilder);
          record.created_at = timestamps.created_at;
          record.updated_at = timestamps.updated_at;
        }

        insertValues.push(encodeInsertValues(record));

        if (hasBatch || recordPos === LAST_POSTION) {
          const query = insertScope + insertValues.join();
          await this.query(query);

          insertValues = [];
        }
      }
    } catch (err) {
      return new Error('[SQL FAST CREATE ERROR] ', err);
    }
  }

  async update(recordBuilder) {
    try {
      const id = recordBuilder.where.UUID;
      const timestamps = createTimestampsFor(recordBuilder);

      invariant(id, `Invalid record ID ${this.table}#${id}`);

      const query = encodeUpdate({
        table: this.table,
        raw: {
          updated_at: timestamps.updated_at,
          ...recordBuilder.columns,
        },
        id,
      });

      await this.query(query[0], query[1]);
      const record = await this.find(id);

      return record;
    } catch (err) {
      return new Error('[SQL UPDATE ERROR] ', err);
    }
  }

  async delete(id) {
    try {
      invariant(id, `Invalid record ID ${this.table}#${id}`);
      
      const validUUid = uuidValidate(id)
      const where = validUUid ? "UUID = '" + id + "'" : "UUID = " + id
     
      const query = `DELETE FROM ${this.table} WHERE ${where}`;
      const response = await this.query(query);

      return this._fetchRecord(response);
    } catch (err) {
      return new Error('[SQL DELETE ERROR] ', err);
    }
  }

  // Clear all data on table
  async clean() {
    try {
      await this.query(`DELETE FROM ${this.table}`);
    } catch (err) {
      return new Error('[SQL CLEAN ERROR] ', err);
    }
  }

  // Fetches exactly one record (See: Collection.find)
  _fetchRecord(records) {
    const data = [];

    for (let i = 0; i < records.rows.length; i++) {
      data.push(records.rows.item(i));
    }

    return data;
  }
}
